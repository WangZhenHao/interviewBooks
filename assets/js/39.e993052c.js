(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{325:function(a,t,s){"use strict";s.r(t);var e=s(14),r=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"es6考点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6考点"}},[a._v("#")]),a._v(" es6考点")]),a._v(" "),t("h3",{attrs:{id:"_1、es5和es6的区别-说一下你所知道的es6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、es5和es6的区别-说一下你所知道的es6"}},[a._v("#")]),a._v(" 1、es5和es6的区别，说一下你所知道的es6")]),a._v(" "),t("ul",[t("li",[a._v("1）let声明变量和const声明常量，两个都有块级作用域ES5中是没有块级作用域的，并且var有变量提升，在let中，使用的变量一定要进行声明")]),a._v(" "),t("li",[a._v("2）箭头函数ES6中的函数定义不再使用关键字function()，而是利用了()=>来进行定义")]),a._v(" "),t("li",[a._v("3）模板字符串模板字符串是增强版的字符串，用反引号（`）标识，可以当作普通字符串使用，也可以用来定义多行字符串")]),a._v(" "),t("li",[a._v("4）解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值")]),a._v(" "),t("li",[a._v("5）for of循环for...of循环可以遍历数组、Set和Map结构、某些类似数组的对象、对象，以及字符串")]),a._v(" "),t("li",[a._v("6）import、export导入导出ES6标准中，Js原生支持模块(module)。将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用")]),a._v(" "),t("li",[a._v("7）set数据结构Set数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数")]),a._v(" "),t("li",[a._v("8）... 展开运算符可以将数组或对象里面的值展开；还可以将多个值收集为一个变量")]),a._v(" "),t("li",[a._v("9）修饰器 @decorator是一个函数，用来修改类甚至于是方法的行为。修饰器本质就是编译时执行的函数")]),a._v(" "),t("li",[a._v("10）class 类的继承ES6中不再像ES5一样使用原型链实现继承，而是引入Class这个概念11）async、await使用 async/await, 搭配promise,可以通过编写形似同步的代码来处理异步流程, 提高代码的简洁性和可读性async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成")]),a._v(" "),t("li",[a._v("12）promisePromise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理、强大")]),a._v(" "),t("li",[a._v("13）SymbolSymbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的")]),a._v(" "),t("li",[a._v("14）Proxy代理使用代理（Proxy）监听对象的操作，然后可以做一些相应事情")])]),a._v(" "),t("h3",{attrs:{id:"_2、var、let、const之间的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、var、let、const之间的区别"}},[a._v("#")]),a._v(" 2、var、let、const之间的区别")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var声明变量可以重复声明，而let不可以重复声明\nvar是不受限于块级的，而let是受限于块级\nvar会与window相映射（会挂一个属性），而let不与window相映射\nvar可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错\nconst声明之后必须赋值，否则会报错\nconst定义不可变的量，改变了就会报错\nconst和let一样不会与window相映射、支持块级作用域、在声明的上面访问变量会报错\n")])])]),t("h3",{attrs:{id:"_3、使用箭头函数应注意什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、使用箭头函数应注意什么"}},[a._v("#")]),a._v(" 3、使用箭头函数应注意什么？")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("（1）用了箭头函数，this就不是指向window，而是父级（指向是可变的）\n（2）不能够使用arguments对象\n（3）不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误\n（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数\n")])])]),t("h3",{attrs:{id:"_4、介绍下-set、map的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、介绍下-set、map的区别"}},[a._v("#")]),a._v(" 4、介绍下 Set、Map的区别？")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("应用场景Set用于数据重组，Map用于数据储存Set：　\n（1）成员不能重复\n（2）只有键值没有键名，类似数组\n（3）可以遍历，方法有add, delete,has\nMap:\n（1）本质上是健值对的集合，类似集合\n（2）可以遍历，可以跟各种数据格式转换\n")])])]),t("h3",{attrs:{id:"_7、promise构造函数是同步执行还是异步执行-那么-then-方法呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7、promise构造函数是同步执行还是异步执行-那么-then-方法呢"}},[a._v("#")]),a._v(" 7、Promise构造函数是同步执行还是异步执行，那么 then 方法呢？")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("promise构造函数是同步执行的，then方法是异步执行的\n")])])]),t("h3",{attrs:{id:"_8、理解-async-await以及对generator的优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8、理解-async-await以及对generator的优势"}},[a._v("#")]),a._v(" 8、理解 async/await以及对Generator的优势")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("async await 是用来解决异步的，async函数是Generator函数的语法糖\n使用关键字async来表示，在函数内部使用 await 来表示异步\nasync函数返回一个 Promise 对象，可以使用then方法添加回调函数\n当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句\nasync较Generator的优势：\n（1）内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，\n     调用方式跟普通函数的调用一样\n（2）更好的语义。async 和 await 相较于 * 和 yield 更加语义化　　\n（3）更广的适用性。yield命令后面只能是 Thunk 函数或 Promise对象，\n     async函数的await后面可以是Promise也可以是原始类型的值\n（4）返回值是 Promise。async 函数返回的是 Promise 对象，\n     比Generator函数返回的Iterator对象方便，可以直接使用 then() 方法进行调用\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);